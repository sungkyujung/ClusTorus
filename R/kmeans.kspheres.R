#' K-Means Clustering to K-Spheres Clustering on Torus
#'
#' \code{kmeans.kspheres} prepares the parameters for conformity scores
#'   which are derived by k-means clustering on torus.
#'
#' @param data data n x d matrix of toroidal data on \eqn{[0, 2\pi)^d}
#' @param centers either the number of clusters or a set of initial
#'   cluster centers. If a number, a random set of row in x is
#'   chosen as the initial centers.
#' @param type character which must be "homogeneous-circular",
#'  "heterogeneous-circular", or "general".
#'   If "homogeneous-circular", the radii of k-spheres are identical.
#'   If "heterogeneous-cricular", the radii of k-spheres may be different.
#'   If, "general", clustering with k-ellipses. The parameters to construct
#'   the ellipses are optimized with generalized Lloyd algorithm, which is
#'   modified for toroidal space. To see the detail, see the references.
#'
#' @return returns a \code{sphere.param} object,
#'   containing all values which determines the shape and
#'   location of spheres.
#'
#' @export
#' @seealso \code{\link[ClusTorus]{ehat.eval}},
#'   \code{\link[ClusTorus]{kmeans.torus}}
#' @references S. Jung, K. Park, and B. Kim (2020),
#'   "Clustering on the torus by conformal prediction", and
#'   Jaehyeok Shin, Alessandro Rinaldo and Larry Wasserman (2019),
#'   "Predictive Clustering"
#' @examples
#' \dontrun{
#' ## mean vectors
#'
#' Mu1 <- c(3, 0)
#' Mu2 <- c(2, 2)
#' Mu3 <- c(1, 4)
#'
#' ## covariance matrices
#'
#' Sigma1 <- matrix(c(0.1, 0.05, 0.05, 0.2), 2, 2)
#' Sigma2 <- matrix(c(0.1, 0, 0, 0.01), 2, 2)
#' Sigma3 <- matrix(c(0.01, 0, 0, 0.1), 2, 2)
#'
#' ## 2-dimensional multivariate normal data wrapped with toroidal space
#' require(MASS)
#' data <- rbind(mvrnorm(n=70, Mu1, Sigma1),
#'               mvrnorm(n=50, Mu2, Sigma2),
#'               mvrnorm(n=50, Mu3, Sigma3))
#' data <- on.torus(data)
#'
#' kmeans.kspheres(data, centers = 3, type = "various")
#' }
kmeans.kspheres <- function(data, centers = 10,
                            type = c("homogeneous-circular",
                                     "heterogeneous-circular",
                                     "general"),
                            parammat = EMsinvMmix.init(data, centers),
                            THRESHOLD = 1e-10, maxiter = 200,
                            verbose = TRUE){

  # Returns a sphere.param object, containing all values which determines
  # the shape and location of spheres

  # type determines kmeans-fitting method. If "identical", the radii of
  # shperes are the same, and if not, the radii may be different.
  type <- match.arg(type)
  d <- ncol(data)
  n <- nrow(data)

  sphere.param <- list(mu1 = NULL, mu2 = NULL, Sigmainv = NULL, c = NULL)

  # Use extrinsic kmeans clustering for initial center points.
  # centers is given as a number, in default, but it may also be given
  # as a matrix which indicates the toroidal points.
  kmeans.out <- kmeans.torus(data, centers = centers,
                             method = "extrinsic")

  centroid <- kmeans.out$centers
  J <- nrow(centroid)
  # -------------- initializing ----------------

  # 1. identical spheres
  # In fact, the initialized parameters are for the identical case.
  sphere.param$mu1 <- centroid[, 1]
  sphere.param$mu2 <- centroid[, 2]
  sphere.param$c <- rep(0, J)

  for(j in 1:J){
    sphere.param$Sigmainv[[j]] <- diag(d)
  }


  # 2. various spheres --------------------------
  if (type == "heterogeneous-circular"){

    for(j in 1:J){

      # if the size of cluster is 1, the cluster contains only one point.
      nj <- kmeans.out$size[j]
      pi_j <- nj / n
      sigma_j <- ifelse(kmeans.out$size[j] == 1,
                        1e-50, kmeans.out$withinss[j] / (nj * d))

      sphere.param$c[j] <- 2 * log(pi_j) - d * log(sigma_j)
      sphere.param$Sigmainv[[j]] <- diag(d) / sigma_j
    }
  }

  # 3. general ellipses ------------------------
  # initialize the parameters with EMsinvMmix.init and norm.appr.param
  # Use generalized Lloyd's algorithm

  else if (type == "general"){
    # Step.1 ------------------------------------
    # initialize the parameters
    sphere.param <- norm.appr.param(parammat)
    J <- ncol(parammat)

    # vectorize the sphere.param: this will be used for escaping loop
    param.seq <- unlist(sphere.param)

    if(verbose){
      cat("kmeans.kspheres: fitting parameters with option ",type, ", J =", J, "\n")
    }

    cnt <- 1
    while(TRUE){
      cnt <- cnt + 1

      if(verbose){if (cnt %% 2 == 0){cat(".")}}

      # Step.2 ------------------------------------
      # prepare w's which work like weights
      wmat <- matrix(0, n, J)


      ehatj <- ehat.eval(data, sphere.param)
      maxj <- apply(ehatj, 1, which.max)

      # evaluate wmat
      for(j in 1:J){ wmat[, j] <- maxj == j }

      # Step.3 -------------------------------------
      # update mu's

      wmat.mul <- apply(wmat, 2, '*', data)
      wmat.mul <- rbind(wmat.mul, wmat)
      wmat.mul <- apply(wmat.mul, 2, function(x){
        wtd.stat.ang(matrix(x[1:(d * n)], n, byrow = F),
                     w = x[((d * n) + 1):length(x)] / sum(x[((d * n) + 1):length(x)]))$Mean})

      mu <- t(wmat.mul)

      sphere.param$mu1 <- mu[, 1]
      sphere.param$mu2 <- mu[, 2]

      sphere.param$mu1[is.na(sphere.param$mu1)] <- 0
      sphere.param$mu2[is.na(sphere.param$mu2)] <- 0
      # Step.4 and Step.5

      for (j in 1:J){

        # Step.4 -----------------------------------
        z <- tor.minus(data, c(sphere.param$mu1[j], sphere.param$mu2[j]))

        # create "flatten" matrix, whose each column indicates
        # the entries of matrix created by (Y_i - mu_j)(Y_i - mu_j)^T
        S <- apply(z, 1, function(x) {as.matrix(x) %*% x})

        S <- matrix(apply(t((t(S) * wmat[, j])), 1, sum), nrow = d) / sum(wmat[, j])

        if (det(S) < THRESHOLD || sum(is.na(S)) != 0){
          S <- THRESHOLD * diag(d)
        }

        sphere.param$Sigmainv[[j]] <- solve(S)

        # Step.5 -----------------------------------
        pi_j <- ifelse(sum(wmat[, j]) == 0, THRESHOLD, sum(wmat[, j]) / n)

        # update c's
        sphere.param$c[j] <- 2 * log(pi_j) - log(det(S))
      }

      param.seq <- rbind(param.seq, unlist(sphere.param))

      diff <- sum((param.seq[nrow(param.seq), ] - param.seq[nrow(param.seq) - 1, ])^2,
                  na.rm = TRUE)

      if (cnt >= maxiter | diff < THRESHOLD){
        cat("Done")
        cat("\n")
        break}
    }
  }
  return(sphere.param)
}
